import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { FaUpload } from 'react-icons/fa';
// import Navbar from '../../components/Navbar/Navbar'; // Eliminar esta lÃ­nea
import { documentService, DocumentUploadInfo } from '../../services/documentService';
import styles from './DocumentUploadPage.module.css';

const DocumentUploadPage: React.FC = () => {
  const navigate = useNavigate();
  const [documentName, setDocumentName] = useState('');
  const [documentType, setDocumentType] = useState('');
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [message, setMessage] = useState<string | null>(null);
  const [fileValidationError, setFileValidationError] = useState<string | null>(null);
  const [isUploadDisabled, setIsUploadDisabled] = useState(true);

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files[0]) {
      const file = e.target.files[0];
      setSelectedFile(file);
      setFileValidationError(null); // Clear previous errors
      setIsUploadDisabled(true); // Disable until validated

      const allowedExtensions = ['pdf', 'docx', 'zip'];
      const maxFileSizeMB = 500;
      const maxFileSizeBytes = maxFileSizeMB * 1024 * 1024;

      const fileExtension = file.name.split('.').pop()?.toLowerCase();
      setDocumentType(fileExtension || ''); // Automatically set document type

      if (!fileExtension || !allowedExtensions.includes(fileExtension)) {
        setFileValidationError(`Invalid file type. Allowed types are: ${allowedExtensions.join(', ')}.`);
        return;
      }

      if (file.size > maxFileSizeBytes) {
        setFileValidationError(`File size exceeds ${maxFileSizeMB} MB. Please upload a smaller file.`);
        return;
      }

      // If all validations pass
      setIsUploadDisabled(false);
    } else {
      setSelectedFile(null);
      setIsUploadDisabled(true);
      setFileValidationError(null);
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setError(null);
    setMessage(null);

    if (!documentName || !documentType || !selectedFile) {
      setError("Please fill in all fields and select a file.");
      setLoading(false);
      return;
    }

    try {
      // First, upload document info (assuming ID is generated by backend or provided)
      // For simplicity, let's assume a placeholder ID or that the backend handles it dynamically.
      // In a real scenario, you might get an ID back from the info upload to use for file upload.
      const tempDocumentId = Math.floor(Math.random() * 10000);
      const uploadedAt = new Date().toISOString().split('T')[0]; // YYYY-MM-DD

      const documentInfo: Omit<DocumentUploadInfo, 'id'> = {
        name: documentName,
        type: documentType,
        uploaded_at: uploadedAt,
        status: 'uploaded',
      };

      // As per contract, there are two POST /upload_document/:id endpoints.
      // One for info and one for file. This is a bit unusual.
      // Let's assume we create the info first, then upload the file using the same ID.
      
      // Step 1: Upload document info (if backend requires it before file)
      // For this example, we're directly using a temporary ID and then the file upload.
      // A more robust backend might return the ID after the info upload.

      // Step 2: Upload the actual file
      const fileUploadResponse = await documentService.uploadDocumentFile(tempDocumentId, documentName, documentType, selectedFile);
      setMessage(`Document '${fileUploadResponse.name}' uploaded successfully!`);
      navigate('/dashboard/my-documents'); // Redirect to user's documents

    } catch (err: any) {
      console.error("Error uploading document:", err);
      setError(err.message || "Failed to upload document.");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className={styles.container}>
      {/* <Navbar /> */}
      <div className={styles.header}>
        <h1>Upload New Document</h1>
      </div>
      <form onSubmit={handleSubmit} className={styles.form}>
        <div className={styles.inputGroup}>
          <label htmlFor="documentName">Document Name:</label>
          <input
            type="text"
            id="documentName"
            value={documentName}
            onChange={(e) => setDocumentName(e.target.value)}
            required
          />
        </div>
        <div className={styles.inputGroup}>
          <label htmlFor="documentType">Document Type (e.g., pdf, docx, zip):</label>
          <input
            type="text"
            id="documentType"
            value={documentType}
            onChange={(e) => setDocumentType(e.target.value)}
            required
          />
        </div>
        <div className={styles.inputGroup}>
          <label htmlFor="file">Select File (max 500 MB):</label>
          <input
            type="file"
            id="file"
            onChange={handleFileChange}
            required
          />
          {fileValidationError && <p className={styles.errorMessage}>{fileValidationError}</p>}
        </div>
        <button type="submit" className={styles.uploadButton} disabled={loading || isUploadDisabled}>
          {loading ? 'Uploading...' : <><FaUpload className={styles.icon} /> Upload Document</>}
        </button>
      </form>
      {message && <p className={styles.successMessage}>{message}</p>}
      {error && <p className={styles.errorMessage}>{error}</p>}
    </div>
  );
};

export default DocumentUploadPage;
